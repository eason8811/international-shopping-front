# 跨境电商系统前端架构与业务/API 切片设计指南

> 适用仓库：`/home/codex/codes/international-shopping-front`  
> 后端参照仓库：`/home/codex/codes/international-shopping`  
> 文档版本：v1.0  
> 更新时间：2026-02-22

## 1. 目标与边界

本指南用于给当前跨境电商系统前端项目提供一套可直接落地的架构方案，覆盖以下内容：

- 前端总体架构（Next.js App Router + BFF + 分层目录）。
- 业务切片（用户端与管理端）与 API 切片（BFF 到后端映射）。
- 与后端当前实现一致的约束（认证、CSRF、幂等、异步状态推进）。
- UI/UX 设计 guideline（结合 `oiloil-ui-ux-guide`，适配 `Tailwind + shadcn/ui + shadcn blocks`）。

原则：

- **代码优先**：后端以已实现代码为准，`AGENTS.md` 仅作补充参考。
- **分阶段交付**：先实现可闭环 MVP，再扩展 customerservice 等未来域。
- **避免前后端耦合泄漏**：前端统一通过 BFF 适配后端，减少协议波动影响面。

## 2. 后端现状全景（以已实现代码为准）

### 2.1 领域落地状态

| 领域 | 状态 | 说明 |
|---|---|---|
| user | 已实现 | 认证、注册、邮箱验证、密码找回、个人资料、地址、OAuth2 绑定 |
| products | 已实现 | 分类树、商品列表/详情、点赞；含完整 admin 商品管理（分类/SPU/SKU/规格/价格） |
| orders | 已实现 | 购物车、下单预览、创建订单、订单查询/取消/改址/退款申请；含 admin 订单、折扣、统计、库存日志 |
| payment | 已实现 | PayPal checkout/capture/cancel、webhook、支付/退款查询与同步 |
| shipping | 已实现 | 用户运单查询、admin 运单管理（面单/发货/手工建单）、17Track webhook |
| customerservice | **未实现（代码层）** | SQL 已有 `cs_ticket`/`aftersales_reship*`，但当前无对应 controller/service/repository 实现 |

补充：`AGENTS.md` 对 customerservice 的描述属于规划态，与当前代码不一致。

### 2.2 与前端强相关的后端协议约束

1. **统一响应包裹**：`Result<T>`。
- 字段：`success/code/message/timestamp/traceId/data/meta`。
- 按当前项目约定：**仅 HTTP 200 代表业务成功**，其他 HTTP 状态码均按业务失败处理；`success` 字段作为一致性兜底校验。

2. **认证机制**：Cookie JWT。
- `access_token` + `refresh_token` Cookie。
- 前端不需要把 JWT 放到 localStorage。

3. **CSRF 双提交**：
- Header：`X-CSRF-Token`。
- Cookie：`csrf_token`。
- 写接口（POST/PUT/PATCH/DELETE）需要处理 CSRF。

4. **幂等键**：多个关键写接口要求 `Idempotency-Key`。
- 下单、支付 checkout、运单操作、地址创建等都涉及幂等。

5. **异步最终一致性**：
- 支付/退款有定时同步任务。
- 支付成功后事务提交后补建占位运单。
- 运单签收后自动推进订单为 `FULFILLED`。
- 订单超时通过 MQ + 定时任务兜底取消。

6. **权限现实约束**：
- 路径有 `/admin/**` 区分。
- 当前代码未见完整 RBAC（例如角色粒度的 `@PreAuthorize("hasRole('ADMIN')")`）。
- 前端要做“管理端入口保护”，但不能把“前端保护”当作真正权限控制。

## 3. 前端总体架构设计

### 3.1 选型结论

- 框架：`Next.js` App Router（RSC 优先）。
- UI：`Tailwind CSS v4 + shadcn/ui + shadcn blocks`。
- 包管理：`pnpm`。
- 架构范式：**Server-first + BFF + Feature Slice**。

### 3.2 核心分层

1. **App Router 路由层**：页面路由、layout、loading/error、metadata。
2. **BFF 层（Route Handlers）**：
- 统一转发后端请求。
- 统一处理 Cookie、CSRF、`Idempotency-Key`、错误映射。
- 为浏览器端屏蔽后端地址和协议细节。
3. **业务切片层（features/entities）**：
- 按业务域组织 TS 类型、查询函数、mutation、状态映射。
4. **共享基础层（shared/lib/components）**：
- API 客户端、Result 解包、错误模型、UI 组件、设计 token。

### 3.3 推荐目录结构

```text
src/
  app/
    (public)/
      page.tsx
      products/
      categories/
    (auth)/
      login/
      register/
      forgot-password/
      oauth2/callback/
    (me)/
      account/
      orders/
      likes/
      addresses/
      cart/
      checkout/
      payments/
      shipments/
    (admin)/
      admin/
        products/
        categories/
        skus/
        orders/
        discounts/
        inventory/
        payments/
        refunds/
        shipments/
        stats/
    api/
      bff/
        auth/
        users/
        products/
        orders/
        payments/
        shipping/
        admin/
  features/
    auth/
    profile/
    address/
    catalog/
    like/
    cart/
    checkout/
    order/
    payment/
    shipment/
    admin-product/
    admin-order/
    admin-payment/
    admin-shipping/
    customer-service/        # 预留
  entities/
    user/
    product/
    order/
    payment/
    shipment/
  components/
    ui/                      # shadcn 基础组件
    blocks/                  # shadcn blocks 复用块
    shared/                  # 站点级复用组件
  lib/
    api/
      client.ts
      bff.ts
      result.ts
      errors.ts
      csrf.ts
      idempotency.ts
    auth/
    format/
    constants/
    schemas/
  styles/
    tokens.css
```

## 4. BFF 与数据访问规范

### 4.1 为什么必须上 BFF

当前后端为 Cookie JWT + CSRF 双提交，且写接口存在幂等键要求。前端若直接跨域调用后端，将长期承担以下复杂度：

- Cookie 同站点策略与跨域 CORS 问题。
- CSRF token 获取、续期、注入逻辑散落在页面代码中。
- `Result<T>` 解包与错误语义无法统一。
- 管理端/用户端错误提示风格不一致。

采用 Next Route Handlers 作为 BFF 后，页面只和 `/api/bff/*` 交互，协议复杂度被收敛在一处。

### 4.2 BFF 统一约定

1. **请求入口统一**：页面层只访问 `/api/bff/**`。
2. **Result 统一解包**：BFF 或 shared client 统一判断：
- HTTP 200 且 `success=true` -> 视为成功并返回 `data`。
- HTTP 200 且 `success=false` -> 抛 `BusinessError(code, message)`（协议一致性兜底）。
- HTTP 非 200 -> 按状态码语义抛错（如 `401/403/404/409/422/429/500`）。
3. **CSRF 自动注入**：
- 写请求从 cookie 读取 `csrf_token`，自动注入 `X-CSRF-Token`。
- 缺 token 时先请求 `/api/v1/auth/csrf` 再重试。
4. **幂等键策略**：
- 对关键写操作（下单、支付、运单、地址创建）自动生成 `Idempotency-Key`。
- 用户主动重试同一动作时复用同一 key。
5. **可观测性**：
- 透传后端 `traceId` 到日志上下文。
- BFF 日志打点：method/path/status/code/duration。

### 4.3 缓存与刷新策略

1. **公开读接口（商品列表/详情/分类）**：
- 使用 RSC `fetch` + tag 缓存。
- 商品变更后通过管理端操作触发 `revalidateTag`。

2. **登录态读接口（购物车、我的订单、我的地址）**：
- 默认 `cache: 'no-store'`。
- 提交 mutation 后 `router.refresh()` + 局部 optimistic UI。

3. **管理端列表（订单/支付/物流）**：
- 默认 `no-store`（优先一致性）。
- 可在报表页做短 TTL 缓存。

## 5. 业务切片与 API 切片设计

### 5.1 用户端（Shop + Me）

#### Slice A：认证与账号

- 页面：`/login` `/register` `/forgot-password` `/oauth2/callback` `/account`。
- BFF：
  - `POST /api/bff/auth/login` -> `POST /api/v1/auth/login`
  - `POST /api/bff/auth/register` -> `POST /api/v1/auth/register`
  - `POST /api/bff/auth/refresh` -> `POST /api/v1/auth/refresh-token`
  - `GET /api/bff/auth/csrf` -> `GET /api/v1/auth/csrf`
  - `GET /api/bff/me` -> `GET /api/v1/users/me`
- 关键点：
  - 登录、注册、找回密码表单走 server/client action 均可，但提交最终统一走 BFF。
  - OAuth2 入口可直接跳后端 authorize URL，callback 落前端页再跳转目标页。

#### Slice B：商品浏览与点赞

- 页面：`/` `/products` `/products/[slug]` `/categories/[slug]` `/likes/products`。
- BFF：
  - `GET /api/bff/products` -> `GET /api/v1/products`
  - `GET /api/bff/products/[slug]` -> `GET /api/v1/products/{slug}`
  - `GET /api/bff/categories/tree` -> `GET /api/v1/products/categories/tree`
  - `PUT/DELETE /api/bff/products/[id]/like` -> 同名后端接口
- 关键点：
  - 列表与详情采用 RSC 首屏渲染。
  - 点赞可 optimistic 更新，失败回滚。

#### Slice C：购物车与下单

- 页面：`/cart` `/checkout`。
- BFF：
  - 购物车 CRUD -> `/api/v1/users/me/cart/items*`
  - 订单预览 -> `POST /api/v1/users/me/orders/preview`
  - 创建订单 -> `POST /api/v1/users/me/orders`（必须 `Idempotency-Key`）
- 关键点：
  - checkout 前必须确保默认地址可用。
  - 创建订单按钮需“防重复点击 + 幂等键复用 + pending 状态锁定”。

#### Slice D：支付与结果回跳

- 页面：`/payments/[paymentId]` `/orders/[orderNo]/pay-result`。
- BFF：
  - checkout -> `POST /api/v1/payments/paypal/checkout`（幂等）
  - capture -> `POST /api/v1/payments/paypal/{payment_id}/capture`
  - cancel -> `POST /api/v1/payments/paypal/{payment_id}/cancel`
- 关键点：
  - capture 结果存在异步补偿，不要假设“返回成功=最终页面稳定”。
  - 前端在支付后进入订单详情时做短周期轮询（如 3s*10 次）再降级为手动刷新。

#### Slice E：订单中心与物流

- 页面：`/orders` `/orders/[orderNo]` `/shipments/[shipmentNo]`。
- BFF：
  - 订单列表/详情/取消/改址/退款申请。
  - 运单查询：
    - `GET /api/v1/users/me/orders/{order_no}/shipments`
    - `GET /api/v1/users/me/shipments/{shipment_no}`
- 关键点：
  - 订单详情页聚合展示：订单状态、支付状态、退款状态、物流状态。
  - 物流状态以时间线组件展示，处理空轨迹/延迟更新提示。

### 5.2 管理端（Admin）

管理端交互策略为“**字段型 PATCH 无感保存优先**，**命令型/高风险操作显式提交**”。

#### Slice F：商品中台

- 页面：`/admin/products` `/admin/products/[id]` `/admin/categories` `/admin/specs`。
- 覆盖接口：`/api/v1/admin/products*`、`/api/v1/admin/products/categories*`、`/api/v1/admin/products/{product_id}/specs*`、`/api/v1/admin/products/{product_id}/skus*`。
- 关键点：
  - 用 URL query 持久化筛选条件（分页、排序、状态）。
  - 无感保存（字段型 PATCH）：`PATCH /admin/products/{product_id}`、`PATCH /admin/products/{product_id}/i18n`、`PATCH /admin/products/categories/{category_id}`、`PATCH /admin/products/categories/{category_id}/i18n`、`PATCH /admin/products/{product_id}/skus/{sku_id}`。
  - 显式提交（命令型或高风险）：`PATCH /admin/products/{product_id}/status`、`PATCH /admin/products/categories/{category_id}/enable`、`PATCH /admin/products/{product_id}/skus/{sku_id}/stock`、`PATCH /admin/products/{product_id}/skus/{sku_id}/price/{currency}/manual|fx-auto`、`POST /admin/products/*/price/recompute`。
  - `stock` 接口在无感模式下仅允许 `mode=SET`；`INCREASE/DECREASE` 保持按钮触发并弹窗确认。

#### Slice G：订单与折扣运营

- 页面：`/admin/orders` `/admin/orders/[orderNo]` `/admin/discounts/*` `/admin/inventory/logs` `/admin/stats`。
- 覆盖接口：
  - `/api/v1/admin/orders*`
  - `/api/v1/admin/discount-policies*`
  - `/api/v1/admin/discount-codes*`
  - `/api/v1/admin/order-discount-applications`
- 关键点：
  - 折扣策略/折扣码基础字段 PATCH（`/admin/discount-policies/{policy_id}`、`/admin/discount-codes/{code_id}`）可做无感保存。
  - 折扣金额模式切换与重算（`manual|fx-auto|recompute`）保持显式提交。
  - 批量与高风险操作（取消订单、关闭订单、确认退款）统一二次确认弹窗。
  - 统计页允许短 TTL 缓存，订单操作页不缓存。

#### Slice H：支付/退款/物流运营

- 页面：`/admin/payments` `/admin/refunds` `/admin/shipments` `/admin/shipments/[id]` `/admin/shipment-status-logs`。
- 覆盖接口：
  - `/api/v1/admin/payments*`
  - `/api/v1/admin/refunds*`
  - `/api/v1/admin/shipments*`
  - `/api/v1/admin/shipment-status-logs`
- 关键点：
  - 该域以命令型接口为主（发货、手工建单、手工同步等），默认不做无感保存。
  - 面单回填、发货、手工建单都要求 `Idempotency-Key`。
  - 日志与详情页强一致，避免缓存误导操作员。

#### 5.2.1 无感保存前端协议（Admin）

1. 触发规则：输入后 `600~800ms debounce` 自动提交；`blur` 立即提交；路由离开前做最后一次 flush。
2. 调度规则：同一资源（如同一个 `product_id`）串行发送 PATCH；若有未完成请求，仅保留“最新值”进入下一次提交。
3. 反馈规则（分层）：页面级常驻显示统一保存状态（`保存中`/`已保存`/`保存失败`）并展示“最近保存时间”；字段级仅在“该字段正在提交”或“该字段保存失败”时显示提示，字段成功态不常驻。
4. 失败处理：`400/422` 绑定字段错误；`401/403` 终止自动保存并要求重新认证；`404` 提示资源已不存在；`409` 在页面级提示“数据已被其他操作更新”并引导刷新；`429/5xx` 指数退避重试。
5. 重试边界：仅自动重试“字段型 PATCH”；命令型接口不自动重试，必须由用户再次触发；字段级错误修复后由下一次输入重新提交。

#### 5.2.2 对当前 API 文档的结论与建议

- 结论：管理侧接口总体方向合理，`PATCH` 覆盖面足够，适合实施无感保存。
- 需调整 1：将 create 与 patch 请求体 schema 拆分，避免 `UpsertRequest` 在 PATCH 场景仍标注大量 `required`。
- 需调整 2：PATCH schema 增加“至少一个字段变更”约束（如 `minProperties: 1` 或 `anyOf(required: [...])`）。
- 需调整 3：为无感保存核心资源补充并发控制协议（建议 `If-Match`/版本号或 `updated_at` 比较），降低多人编辑覆盖风险。
- 需调整 4：在 API 文档中显式标注“字段型 PATCH（autosave-safe）”与“命令型 PATCH（manual-submit-only）”，避免前端误用。

### 5.3 未来域预留：customerservice

当前后端未实现 customerservice API，但 SQL 已建表。前端建议提前预留：

- 路由占位：`/admin/customer-service`、`/admin/tickets/[id]`。
- 代码占位：`features/customer-service`、`entities/ticket`。
- 功能开关：`NEXT_PUBLIC_FEATURE_CUSTOMER_SERVICE=false`。

这样可以保证未来接入时不需要重构主路由。

## 6. 状态机与前端状态映射

### 6.1 统一状态 badge 映射

建议在 `lib/constants/status-map.ts` 维护单一映射表，覆盖：

- `OrderStatus`: `CREATED/PENDING_PAYMENT/PAID/CANCELLED/CLOSED/FULFILLED/REFUNDING/REFUNDED`
- `PaymentStatus`: `NONE/INIT/PENDING/SUCCESS/FAIL/CLOSED/EXCEPTION`
- `RefundStatus`: `INIT/PENDING/SUCCESS/FAIL/CLOSED/EXCEPTION`
- `ShipmentStatus`: `CREATED/LABEL_CREATED/PICKED_UP/IN_TRANSIT/CUSTOMS_PROCESSING/CUSTOMS_HOLD/CUSTOMS_RELEASED/HANDED_OVER/OUT_FOR_DELIVERY/DELIVERED/EXCEPTION/RETURNED/CANCELLED/LOST`

要求：

- 颜色语义稳定（成功=绿色系，异常=红色系，处理中=中性色或蓝色系）。
- 文案短且一致（例如“处理中”只对应一类语义）。
- 同状态在用户端与管理端视觉一致。

### 6.2 异步一致性 UI 策略

1. 支付成功后：
- 页面立即反馈“支付结果已提交”。
- 订单详情区展示“状态同步中”并短轮询。

2. 退款处理中：
- 显示“退款处理中，最终结果可能延迟”。
- 给出“稍后刷新/返回订单中心”操作。

3. 物流轨迹：
- 空轨迹不报错，显示“物流信息同步中”。
- 延迟回调时保留上次更新时间。

## 7. UI/UX Guideline（结合 oiloil-ui-ux-guide）

### 7.1 非协商规则

- 不使用 emoji 作为图标或装饰。
- 图标统一 `lucide-react`，禁止混用多套图标风格。
- 文案最小化，只保留能减少误解和错误的说明。

### 7.2 任务优先与信息架构

- 每个页面只保留一个主 CTA。
- 页面在 3 秒内让用户看懂“当前任务是什么”。
- 管理端列表先做筛选/搜索/排序，再做装饰。

### 7.3 CRAP 执行标准

1. Contrast：主按钮、关键金额、当前状态必须具备足够对比。
2. Repetition：统一间距标尺（4/8/12/16/24/32/40/48）。
3. Alignment：卡片、表单、表格统一网格，消除 1-2px 漂移。
4. Proximity：同组紧凑、组间留白更大，靠间距分组而不是加边框。

### 7.4 建议视觉方向（首版）

- 风格：现代简洁、偏“运营仪表 + 交易系统”气质。
- 字体：避免默认系统感，建议 `Manrope`（正文）+ `JetBrains Mono`（金额/单号）。
- 色彩：中性底色 + 单一强调色（建议蓝绿系，不用紫色主调）。
- 动效：仅用于层级变化与状态变化，不做装饰性大动效。

## 8. 工程规范与实现建议

### 8.1 TypeScript 类型与校验

- 在 `entities/*` 下定义领域 DTO 与 ViewModel。
- 在 `lib/schemas` 使用 `zod` 做运行时校验（建议新增依赖）。
- 严禁页面中直接拼接后端响应字段，统一走 mapper。

### 8.2 表单与错误处理

- 建议 `react-hook-form + zod resolver`。
- 错误提示分层：
  - 字段级错误（输入下方）
  - 表单级错误（表单顶部）
  - 全局错误（仅跨页面影响时 toast）

### 8.3 URL 状态即页面状态

- 列表页筛选项全部放 query string。
- 支持分享链接后状态可还原。

### 8.4 鉴权守卫

- `middleware.ts` 做前端路由守卫：
  - 未登录访问 `/me/*`、`/admin/*` 跳转 `/login`。
- 注意：该守卫仅提升体验，不替代后端鉴权。

## 9. 迭代计划（建议）

### Phase 0：基础设施（1 周）

- 建立目录骨架、BFF 基建、Result 解包、错误模型、状态映射。
- 完成登录态探测、CSRF 初始化、全局 layout 与 design token。

### Phase 1：用户端 MVP（2-3 周）

- 商品列表/详情、购物车、下单、支付、订单列表/详情、物流详情。
- 覆盖核心转化链路：浏览 -> 下单 -> 支付 -> 查单。

### Phase 2：管理端 MVP（2-3 周）

- 商品管理、订单管理、支付/退款管理、运单管理、基础统计。
- 建立操作审慎机制（确认弹窗、幂等提示、状态回显）。

### Phase 3：增强与 customerservice 接入准备（持续）

- 接入 customerservice API（后端完成后）。
- 优化性能、可观测性、埋点与 A/B。

## 10. 风险与待确认项

1. **跨域/CORS 策略**：后端当前仅 `http.cors(Customizer.withDefaults())`，未见明确 CORS 白名单配置。若前后端分域，需尽快明确部署策略。
2. **admin 权限模型**：目前缺少严格 RBAC 约束。上线前需补后端权限控制。
3. **customerservice API 时间点**：前端已预留切片，需后端给出接口节奏。
4. **品牌设计基线**：首版视觉 token（字体/色盘/间距）建议在 Phase 0 确认，避免后期大规模返工。

## 11. 参考（官方文档）

- Next.js App Router（Routing & Layouts）：https://nextjs.org/docs/app
- Server and Client Components：https://nextjs.org/docs/app/getting-started/server-and-client-components
- Fetching Data：https://nextjs.org/docs/app/getting-started/fetching-data
- Updating Data / Server Actions：https://nextjs.org/docs/app/getting-started/updating-data
- Caching and Revalidating：https://nextjs.org/docs/app/getting-started/caching-and-revalidating
- Route Handlers：https://nextjs.org/docs/app/getting-started/route-handlers
- Backend for Frontend（Guide）：https://nextjs.org/docs/app/guides/backend-for-frontend
