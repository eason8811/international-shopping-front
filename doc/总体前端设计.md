# 跨境电商系统前端架构与业务/API 切片设计指南

> 适用仓库：`/home/codex/codes/international-shopping-front`  
> 后端参照仓库：`/home/codex/codes/international-shopping`  
> 文档版本：v1.2  
> 更新时间：2026-02-28

## 1. 目标与边界

本指南用于给当前跨境电商系统前端项目提供一套可直接落地的架构方案，覆盖以下内容：

- 前端总体架构（Next.js App Router + BFF + 分层目录）。
- 业务切片（用户端与管理端）与 API 切片（BFF 到后端映射）。
- 与后端当前实现一致的约束（认证、CSRF、幂等、异步状态推进）。
- UI/UX 设计 guideline（结合 `oiloil-ui-ux-guide`，适配 `Tailwind + shadcn/ui + shadcn blocks`）。

原则：

- **契约优先**：前后端协作以已落地 API 文档（v1.3.0）+ DDL + 已实现代码三者交集为准。
- **分阶段交付**：先实现交易闭环 MVP，再分阶段接入 customerservice 等增强域。
- **避免前后端耦合泄漏**：前端统一通过 BFF 适配后端，减少协议波动影响面。

## 2. 后端现状全景（以 API 文档 + DDL + 已实现代码为准）

### 2.1 领域落地状态

| 领域 | 状态 | 说明 |
|---|---|---|
| user | 已实现 | 认证、注册、邮箱验证、密码找回、个人资料、地址、OAuth2 绑定 |
| products | 已实现 | 分类树、商品列表/详情、点赞；含完整 admin 商品管理（分类/SPU/SKU/规格/价格） |
| orders | 已实现 | 购物车、下单预览、创建订单、订单查询/取消/改址/退款申请；含 admin 订单、折扣、统计、库存日志 |
| payment | 已实现 | PayPal checkout/capture/cancel、webhook、支付/退款查询与同步 |
| shipping | 已实现 | 用户运单查询、admin 运单管理（面单/发货/手工建单）、17Track webhook |
| customerservice | **API/DDL 已完善（实现进度待联调确认）** | 已提供用户侧工单、管理侧工单/补发、会话相关 API 文档；SQL 已有 `cs_ticket`/`aftersales_reship*` 全量结构 |

### 2.2 与前端强相关的后端协议约束

1. **统一响应包裹**：`Result<T>`。
- 字段：`success/code/message/timestamp/traceId/data/meta`。
- 按当前项目约定：**仅 HTTP 200 代表业务成功**，其他 HTTP 状态码均按业务失败处理；`success` 字段作为一致性兜底校验。

2. **认证机制**：Cookie JWT。
- `access_token` + `refresh_token` Cookie。
- 前端不需要把 JWT 放到 localStorage。

3. **CSRF 双提交**：
- Header：`X-CSRF-Token`。
- Cookie：`csrf_token`。
- 写接口（POST/PUT/PATCH/DELETE）需要处理 CSRF。

4. **幂等键**：所有声明 `Idempotency-Key` 的写接口，前端一律必传。
- BFF 统一生成并在“同一业务动作重试”时复用同一 key，避免重复创建资源。

5. **异步最终一致性**：
- 支付/退款有定时同步任务。
- 支付成功后事务提交后补建占位运单。
- 运单签收后自动推进订单为 `FULFILLED`。
- 订单超时通过 MQ + 定时任务兜底取消。

6. **权限模型约束**：
- 后端 RBAC 已落地，JWT 已包含 RBAC 所需信息（角色/权限声明）。
- 前端基于 JWT claim 做路由守卫与可见性控制（菜单、按钮、操作入口）。
- 最终权限裁决始终以后端为准，前端仅做体验层防误操作。

## 3. 前端总体架构设计

### 3.1 选型结论

- 框架：`Next.js` App Router（RSC 优先）。
- UI：`Tailwind CSS v4 + shadcn/ui + shadcn blocks`。
- 包管理：`pnpm`。
- 架构范式：**Server-first + BFF + Feature Slice**。

### 3.2 核心分层

1. **App Router 路由层**：页面路由、layout、loading/error、metadata。
2. **BFF 层（Route Handlers）**：
- 统一转发后端请求。
- 统一处理 Cookie、CSRF、`Idempotency-Key`、错误映射。
- 为浏览器端屏蔽后端地址和协议细节。
3. **业务切片层（features/entities）**：
- 按业务域组织 TS 类型、查询函数、mutation、状态映射。
4. **共享基础层（shared/lib/components）**：
- API 客户端、Result 解包、错误模型、UI 组件、设计 token。

### 3.3 推荐目录结构

```text
src/
  app/
    (public)/
      page.tsx
      products/
      categories/
    (auth)/
      login/
      register/
      forgot-password/
      oauth2/callback/
    (me)/
      account/
      orders/
      likes/
      addresses/
      cart/
      checkout/
      payments/
      shipments/
    (admin)/
      admin/
        products/
        categories/
        skus/
        orders/
        discounts/
        inventory/
        payments/
        refunds/
        shipments/
        stats/
    api/
      bff/
        auth/
        users/
        products/
        orders/
        payments/
        shipping/
        admin/
  features/
    auth/
    profile/
    address/
    catalog/
    like/
    cart/
    checkout/
    order/
    payment/
    shipment/
    admin-product/
    admin-order/
    admin-payment/
    admin-shipping/
    customer-service/        # 预留
  entities/
    user/
    product/
    order/
    payment/
    shipment/
  components/
    ui/                      # shadcn 基础组件
    blocks/                  # shadcn blocks 复用块
    shared/                  # 站点级复用组件
  lib/
    api/
      client.ts
      bff.ts
      result.ts
      errors.ts
      csrf.ts
      idempotency.ts
    auth/
    format/
    constants/
    schemas/
  styles/
    tokens.css
```

## 4. BFF 与数据访问规范

### 4.1 为什么必须上 BFF

当前后端为 Cookie JWT + CSRF 双提交，且写接口存在幂等键要求。你当前规划是“同机多容器部署 + Nginx 反代统一域名”，可显著降低浏览器跨域复杂度；但前端若直接调用后端，仍会承担以下复杂度：

- 反代与环境差异下的 Cookie 同站点策略/CORS 配置一致性问题。
- CSRF token 获取、续期、注入逻辑散落在页面代码中。
- `Result<T>` 解包与错误语义无法统一。
- 管理端/用户端错误提示风格不一致。

采用 Next Route Handlers 作为 BFF 后，页面只和 `/api/bff/*` 交互，协议复杂度被收敛在一处。

### 4.2 BFF 统一约定

1. **请求入口统一**：页面层只访问 `/api/bff/**`。
2. **Result 统一解包**：BFF 或 shared client 统一判断：
- HTTP 200 且 `success=true` -> 视为成功并返回 `data`。
- HTTP 200 且 `success=false` -> 抛 `BusinessError(code, message)`（协议一致性兜底）。
- HTTP 非 200 -> 按状态码语义抛错（如 `401/403/404/409/422/429/500`）。
3. **CSRF 自动注入**：
- 写请求从 cookie 读取 `csrf_token`，自动注入 `X-CSRF-Token`。
- 缺 token 时先请求 `/api/v1/auth/csrf` 再重试。
4. **幂等键策略**：
- 对所有声明 `Idempotency-Key` 的写接口自动生成并注入。
- 用户主动重试同一动作时复用同一 key。
5. **可观测性**：
- 透传后端 `traceId` 到日志上下文。
- BFF 日志打点：method/path/status/code/duration。

### 4.3 缓存与刷新策略

1. **公开读接口（商品列表/详情/分类）**：
- 使用 RSC `fetch` + tag 缓存。
- 商品变更后通过管理端操作触发 `revalidateTag`。

2. **登录态读接口（购物车、我的订单、我的地址）**：
- 默认 `cache: 'no-store'`。
- 提交 mutation 后 `router.refresh()` + 局部 optimistic UI。

3. **管理端列表（订单/支付/物流）**：
- 默认 `no-store`（优先一致性）。
- 可在报表页做短 TTL 缓存。

## 5. 业务切片与 API 切片设计

### 5.1 用户端（Shop + Me）

#### Slice A：认证与账号

- 页面：`/login` `/register` `/forgot-password` `/oauth2/callback` `/account`。
- BFF：
  - `POST /api/bff/auth/login` -> `POST /api/v1/auth/login`
  - `POST /api/bff/auth/register` -> `POST /api/v1/auth/register`
  - `POST /api/bff/auth/refresh` -> `POST /api/v1/auth/refresh-token`
  - `GET /api/bff/auth/csrf` -> `GET /api/v1/auth/csrf`
  - `GET /api/bff/me` -> `GET /api/v1/users/me`
- 关键点：
  - 登录、注册、找回密码表单走 server/client action 均可，但提交最终统一走 BFF。
  - OAuth2 入口可直接跳后端 authorize URL，callback 落前端页再跳转目标页。

#### Slice B：商品浏览与点赞

- 页面：`/` `/products` `/products/[slug]` `/categories/[slug]` `/likes/products`。
- BFF：
  - `GET /api/bff/products` -> `GET /api/v1/products`
  - `GET /api/bff/products/[slug]` -> `GET /api/v1/products/{slug}`
  - `GET /api/bff/categories/tree` -> `GET /api/v1/products/categories/tree`
  - `PUT/DELETE /api/bff/products/[id]/like` -> 同名后端接口
- 关键点：
  - 列表与详情采用 RSC 首屏渲染。
  - 点赞可 optimistic 更新，失败回滚。

#### Slice C：购物车与下单

- 页面：`/cart` `/checkout`。
- BFF：
  - 购物车 CRUD -> `/api/v1/users/me/cart/items*`
  - 订单预览 -> `POST /api/v1/users/me/orders/preview`
  - 创建订单 -> `POST /api/v1/users/me/orders`（必须 `Idempotency-Key`）
- 关键点：
  - checkout 前必须确保默认地址可用。
  - 创建订单按钮需“防重复点击 + 幂等键复用 + pending 状态锁定”。

#### Slice D：支付与结果回跳

- 页面：`/payments/[paymentId]` `/orders/[orderNo]/pay-result`。
- BFF：
  - checkout -> `POST /api/v1/payments/paypal/checkout`（幂等）
  - capture -> `POST /api/v1/payments/paypal/{payment_id}/capture`
  - cancel -> `POST /api/v1/payments/paypal/{payment_id}/cancel`
- 关键点：
  - capture 结果存在异步补偿，不要假设“返回成功=最终页面稳定”。
  - 前端在支付后进入订单详情时做短周期轮询（如 3s*10 次）再降级为手动刷新。

#### Slice E：订单中心与物流

- 页面：`/orders` `/orders/[orderNo]` `/shipments/[shipmentNo]`。
- BFF：
  - 订单列表/详情/取消/改址/退款申请。
  - 运单查询：
    - `GET /api/v1/users/me/orders/{order_no}/shipments`
    - `GET /api/v1/users/me/shipments/{shipment_no}`
- 关键点：
  - 订单详情页聚合展示：订单状态、支付状态、退款状态、物流状态。
  - 物流状态以时间线组件展示，处理空轨迹/延迟更新提示。

### 5.2 管理端（Admin）

管理端交互策略为“**字段型 PATCH 无感保存优先**，**命令型/高风险操作显式提交**”。

#### Slice F：商品中台

- 页面：`/admin/products` `/admin/products/[id]` `/admin/categories` `/admin/specs`。
- 覆盖接口：`/api/v1/admin/products*`、`/api/v1/admin/products/categories*`、`/api/v1/admin/products/{product_id}/specs*`、`/api/v1/admin/products/{product_id}/skus*`。
- 关键点：
  - 用 URL query 持久化筛选条件（分页、排序、状态）。
  - 无感保存（字段型 PATCH）：`PATCH /admin/products/{product_id}`、`PATCH /admin/products/{product_id}/i18n`、`PATCH /admin/products/categories/{category_id}`、`PATCH /admin/products/categories/{category_id}/i18n`、`PATCH /admin/products/{product_id}/skus/{sku_id}`。
  - 显式提交（命令型或高风险）：`PATCH /admin/products/{product_id}/status`、`PATCH /admin/products/categories/{category_id}/enable`、`PATCH /admin/products/{product_id}/skus/{sku_id}/stock`、`PATCH /admin/products/{product_id}/skus/{sku_id}/price/{currency}/manual|fx-auto`、`POST /admin/products/*/price/recompute`。
  - `stock` 接口在无感模式下仅允许 `mode=SET`；`INCREASE/DECREASE` 保持按钮触发并弹窗确认。

#### Slice G：订单与折扣运营

- 页面：`/admin/orders` `/admin/orders/[orderNo]` `/admin/discounts/*` `/admin/inventory/logs` `/admin/stats`。
- 覆盖接口：
  - `/api/v1/admin/orders*`
  - `/api/v1/admin/discount-policies*`
  - `/api/v1/admin/discount-codes*`
  - `/api/v1/admin/order-discount-applications`
- 关键点：
  - 折扣策略/折扣码基础字段 PATCH（`/admin/discount-policies/{policy_id}`、`/admin/discount-codes/{code_id}`）可做无感保存。
  - 折扣金额模式切换与重算（`manual|fx-auto|recompute`）保持显式提交。
  - 批量与高风险操作（取消订单、关闭订单、确认退款）统一二次确认弹窗。
  - 统计页允许短 TTL 缓存，订单操作页不缓存。

#### Slice H：支付/退款/物流运营

- 页面：`/admin/payments` `/admin/refunds` `/admin/shipments` `/admin/shipments/[id]` `/admin/shipment-status-logs`。
- 覆盖接口：
  - `/api/v1/admin/payments*`
  - `/api/v1/admin/refunds*`
  - `/api/v1/admin/shipments*`
  - `/api/v1/admin/shipment-status-logs`
- 关键点：
  - 该域以命令型接口为主（发货、手工建单、手工同步等），默认不做无感保存。
  - 面单回填、发货、手工建单都要求 `Idempotency-Key`。
  - 日志与详情页强一致，避免缓存误导操作员。

#### 5.2.1 无感保存前端协议（Admin）

1. 触发规则：输入后 `600~800ms debounce` 自动提交；`blur` 立即提交；路由离开前做最后一次 flush。
2. 调度规则：同一资源（如同一个 `product_id`）串行发送 PATCH；若有未完成请求，仅保留“最新值”进入下一次提交。
3. 反馈规则（分层）：页面级常驻显示统一保存状态（`保存中`/`已保存`/`保存失败`）并展示“最近保存时间”；字段级仅在“该字段正在提交”或“该字段保存失败”时显示提示，字段成功态不常驻。
4. 失败处理：`400/422` 绑定字段错误；`401/403` 终止自动保存并要求重新认证；`404` 提示资源已不存在；`409` 在页面级提示“数据已被其他操作更新”并引导刷新；`429/5xx` 指数退避重试。
5. 重试边界：仅自动重试“字段型 PATCH”；命令型接口不自动重试，必须由用户再次触发；字段级错误修复后由下一次输入重新提交。

#### 5.2.2 对当前 API 文档的结论与建议（基于 v1.3.0）

- 结论 1（已改善）：六大领域 API 路径覆盖已完整，前端可以按 `user/products/orders/payment/shipping/customerservice` 切片并行推进。
- 结论 2（已改善）：命令型接口边界更清晰（如 `status/recompute/sync/dispatch/assign`），便于前端明确“无感保存 vs 显式提交”。
- 结论 3（部分改善）：customerservice 已出现 `CreateRequest/PatchRequest` 分离（如 `AdminTicketPatchRequest`、`AdminReshipPatchRequest`），该域可直接按字段型 PATCH 表单落地。
- 待完善 1：`products/orders` 仍大量复用 `*UpsertRequest` 到 PATCH（如 `CategoryUpsertRequest`、`ProductSpuBasicUpsertRequest`、`DiscountPolicyUpsertRequest`、`DiscountCodeUpsertRequest`、`CartItemUpsertRequest`），依然存在 PATCH 语义被 `required` 限制的风险。
- 待完善 2：字段型 PATCH schema 仍缺“至少一个字段变更”约束，建议统一补 `minProperties: 1` 或 `anyOf(required: [...])`。
- 待完善 3：尚未看到通用并发控制（`If-Match`/版本号/`expected_updated_at`）协议；多人并行编辑时仍可能互相覆盖。
- 待完善 4：API 文档未显式标注 `autosave-safe` / `manual-submit-only`；建议在 operation 上增加 vendor extension（如 `x-write-mode`）供前端自动分流。
- 已确认：所有声明 `Idempotency-Key` 的接口按“必传”执行；OpenAPI 里仍标注 optional 的接口需在后续版本同步更正为 required。

### 5.3 customerservice 域接入设计（由预留改为可落地）

customerservice API 文档与 DDL 已具备接入条件，建议采用“功能开关 + 渐进接入”：

- 用户侧路由：`/me/tickets`、`/me/tickets/[ticketNo]`（建单、消息、读标记、关闭工单、补发查询）。
- 管理侧路由：`/admin/customer-service/tickets`、`/admin/customer-service/tickets/[id]`、`/admin/customer-service/reships`、`/admin/customer-service/reships/[id]`。
- 代码切片：`features/customer-service`、`entities/ticket`、`entities/reship`、`entities/ticket-message`。
- 功能开关：
  - `NEXT_PUBLIC_FEATURE_CUSTOMER_SERVICE_USER=false`
  - `NEXT_PUBLIC_FEATURE_CUSTOMER_SERVICE_ADMIN=false`
- 上线节奏：
  - 第一步：仅开“用户侧工单查询 + 管理侧列表只读”。
  - 第二步：开放“消息、指派、状态流转、补发绑定运单”等写操作。
- 技术注意：实时通道采用“先申请再升级”：
  - 升级申请接口：`/users/me/ws-sessions`、`/admin/ws-sessions`。
  - 申请返回字段：`ws_token`、`ws_url`、`issued_at`、`expires_at`、`heartbeat_interval_seconds`、`resume_ttl_seconds`。
  - WebSocket 升级后的消息结构，按 `customerservice` API 中前缀 `CsWs**` 的数据模型与“建立售后消息 WebSocket 连接”接口说明实现。

## 6. 状态机与前端状态映射

### 6.1 统一状态 badge 映射

建议在 `lib/constants/status-map.ts` 维护单一映射表，覆盖：

- `OrderStatus`: `CREATED/PENDING_PAYMENT/PAID/CANCELLED/CLOSED/FULFILLED/REFUNDING/REFUNDED`
- `PayStatus`（以 DDL `orders.pay_status` 为准）：`NONE/INIT/PENDING/SUCCESS/FAIL/CLOSED/EXCEPTION`
- `PaymentStatus`: `NONE/INIT/PENDING/SUCCESS/FAIL/CLOSED/EXCEPTION`
- `RefundStatus`: `INIT/PENDING/SUCCESS/FAIL/CLOSED/EXCEPTION`
- `ShipmentStatus`: `CREATED/LABEL_CREATED/PICKED_UP/IN_TRANSIT/CUSTOMS_PROCESSING/CUSTOMS_HOLD/CUSTOMS_RELEASED/HANDED_OVER/OUT_FOR_DELIVERY/DELIVERED/EXCEPTION/RETURNED/CANCELLED/LOST`
- `CsTicketStatus`: `OPEN/IN_PROGRESS/AWAITING_USER/AWAITING_CARRIER/ON_HOLD/RESOLVED/REJECTED/CLOSED`
- `AfterSalesReshipStatus`: `INIT/APPROVED/FULFILLING/FULFILLED/CANCELLED`

要求：

- 颜色语义稳定（成功=绿色系，异常=红色系，处理中=中性色）。
- 文案短且一致（例如“处理中”只对应一类语义）。
- 同状态在用户端与管理端视觉一致。

### 6.2 异步一致性 UI 策略

1. 支付成功后：
- 页面立即反馈“支付结果已提交”。
- 订单详情区展示“状态同步中”并短轮询。

2. 退款处理中：
- 显示“退款处理中，最终结果可能延迟”。
- 给出“稍后刷新/返回订单中心”操作。

3. 物流轨迹：
- 空轨迹不报错，显示“物流信息同步中”。
- 延迟回调时保留上次更新时间。

## 7. UI/UX Guideline（结合 oiloil-ui-ux-guide）

### 7.1 非协商规则

- 不使用 emoji 作为图标或装饰。
- 图标统一 `lucide-react`，禁止混用多套图标风格。
- 文案最小化，只保留能减少误解和错误的说明。

### 7.2 任务优先与信息架构

- 每个页面只保留一个主 CTA。
- 页面在 3 秒内让用户看懂“当前任务是什么”。
- 管理端列表先做筛选/搜索/排序，再做装饰。

### 7.3 CRAP 执行标准

1. Contrast：主按钮、关键金额、当前状态必须具备足够对比。
2. Repetition：统一间距标尺（4/8/12/16/24/32/40/48）。
3. Alignment：卡片、表单、表格统一网格，消除 1-2px 漂移。
4. Proximity：同组紧凑、组间留白更大，靠间距分组而不是加边框。

### 7.4 建议视觉方向（首版）

- 风格：现代简洁、偏“运营仪表 + 交易系统”气质。
- 字体：避免默认系统感，建议 `Manrope`（正文）+ `JetBrains Mono`（金额/单号）。
- 色彩：中性底色 + 单一强调色（建议黑色系，避免强调色与多彩的商品图争夺主位）。
- 动效：仅用于层级变化与状态变化，不做装饰性大动效，需要顺滑且有灵动感。

## 8. 工程规范与实现建议

### 8.1 TypeScript 类型与校验

- 在 `entities/*` 下定义领域 DTO 与 ViewModel。
- 在 `lib/schemas` 使用 `zod` 做运行时校验（建议新增依赖）。
- 严禁页面中直接拼接后端响应字段，统一走 mapper。

### 8.2 表单与错误处理

- 建议 `react-hook-form + zod resolver`。
- 错误提示分层：
  - 字段级错误（输入下方或右侧）
  - 表单级错误（表单顶部）
  - 全局错误（仅跨页面影响时 toast）

### 8.3 URL 状态即页面状态

- 列表页筛选项全部放 query string。
- 支持分享链接后状态可还原。

### 8.4 鉴权守卫

- `middleware.ts` 做前端路由守卫：
  - 未登录访问 `/me/*`、`/admin/*` 跳转 `/login`。
- 注意：该守卫仅提升体验，不替代后端鉴权。

## 9. 迭代计划（细化版，建议）

### 9.1 里程碑节奏（建议 10-12 周）

- M0（第 1 周）：工程底座可用，BFF/鉴权/CSRF/错误模型打通。
- M1（第 2-4 周）：用户侧交易闭环完成（浏览 -> 下单 -> 支付 -> 查单）。
- M2（第 5-8 周）：管理侧核心运营闭环完成（商品 -> 订单/折扣 -> 支付退款 -> 物流）。
- M3（第 9-10 周）：customerservice 基础闭环完成（工单 -> 消息 -> 指派/状态 -> 补发）。
- M4（第 11-12 周）：联调压测、灰度发布、上线验收。

### Phase 0：工程底座与契约层（1 周）

- 范围：
  - 建立 `app/bff/features/entities/shared` 目录骨架。
  - 建立统一 `Result<T>` 解包、错误码映射、分页模型、traceId 透传。
  - 建立 Cookie 鉴权、CSRF 双提交、`Idempotency-Key` 注入策略。
  - 建立 `status-map.ts`（含订单/支付/退款/物流/客服/补发状态）。
- 关键接口：
  - `GET /auth/csrf`、`POST /auth/refresh-token`、`GET /users/me`。
- 验收标准：
  - 90% 以上写接口通过统一 BFF 客户端发送。
  - 未登录、CSRF 失败、429、5xx 在 UI 上有统一且可追踪的错误展示。

### Phase 1：账号与地址（1 周）

- 范围：
  - 登录、注册、找回密码、邮箱状态检查、退出登录。
  - 个人信息读取/更新、地址 CRUD、设置默认地址。
- 关键接口：
  - `user` 域 `auth/*`、`/users/me`、`/users/me/profile`、`/users/me/addresses*`。
- 验收标准：
  - 从未登录到“可下单”路径可一次完成（含默认地址配置）。
  - 地址写接口幂等重试不产生重复地址记录。

### Phase 2：商品浏览与购物车（1-1.5 周）

- 范围：
  - 分类树、商品列表、商品详情、点赞列表。
  - 购物车增删改查、数量与勾选状态维护。
- 关键接口：
  - `product` 域公开接口与 `orders` 域购物车接口。
- 验收标准：
  - 商品列表/详情首屏使用 RSC，列表筛选可通过 URL 还原。
  - 购物车更新失败可回滚并恢复一致状态。

### Phase 3：下单与支付闭环（1-1.5 周）

- 范围：
  - 订单预览、创建订单、PayPal checkout/capture/cancel、支付结果页。
  - 订单支付状态轮询与最终一致性提示。
- 关键接口：
  - `POST /users/me/orders/preview`
  - `POST /users/me/orders`（幂等）
  - `POST /payments/paypal/checkout|capture|cancel`
- 验收标准：
  - 核心链路 `浏览 -> 下单 -> 支付` 成功率可观测。
  - 重复点击下单不会产生重复订单（对齐 DDL `uk_order_idempotency`）。

### Phase 4：订单中心与物流查询（1 周）

- 范围：
  - 订单列表/详情、取消订单、改地址、退款申请。
  - 运单列表/详情与物流状态时间线。
- 关键接口：
  - `orders` 域用户侧订单接口、`shipping` 域用户侧运单接口。
- 验收标准：
  - 订单详情页可聚合展示 `OrderStatus/PayStatus/ShipmentStatus`。
  - 空轨迹、延迟同步、状态回退均有明确 UI 文案。

### Phase 5：管理端商品中台（2 周）

- 范围：
  - 分类/SPU/i18n/规格/SKU/价格/库存/上下架全链路。
  - 接入“字段型 PATCH 无感保存 + 命令型显式提交”策略。
- 关键接口：
  - `product` 域全部 admin 接口，特别是 `status/stock/price/recompute`。
- 验收标准：
  - 字段型 PATCH 支持 debounce、串行提交、失败可重试。
  - 命令型操作必须二次确认，并记录幂等键与操作结果。

### Phase 6：管理端交易运营（2 周）

- 范围：
  - 管理端订单、折扣策略/折扣码、支付查询与同步、退款查询、运单运营（面单/发货/手工建单）。
  - 统计看板与操作审慎机制（确认、回显、审计日志入口）。
- 关键接口：
  - `orders/admin*`、`payment/admin*`、`shipping/admin*`。
- 验收标准：
  - 折扣、支付、物流三类高风险操作都具备防重复提交。
  - 管理页可从主数据跳转至状态日志（订单/库存/运单状态流转）。

### Phase 7：customerservice 基础闭环（2 周）

- 范围：
  - 用户侧：工单创建/查询/详情、消息发送、已读标记、关闭工单、补发查询。
  - 管理侧：工单列表/详情、指派、状态流转、消息编辑/撤回、参与方管理、补发单管理与绑定运单。
  - 先轮询后实时：优先 HTTP，后续接入 `ws-sessions`。
- 关键接口：
  - `customerservice` 域 `users/me/tickets*`、`admin/tickets*`、`admin/reships*`。
- 验收标准：
  - 工单到补发的关键状态可闭环流转（对齐 `cs_ticket*` 与 `aftersales_reship*` 表）。
  - 用户与管理端对同一工单的状态显示一致。

### Phase 8：联调、质量与上线（1-2 周）

- 范围：
  - 契约回归、端到端冒烟、错误注入测试、性能与可观测性补齐。
  - 灰度策略、回滚预案、运营手册。
- 验收标准：
  - 关键路径 E2E 全绿：登录、下单、支付、退款申请、发货、工单处理。
  - 关键写接口具备幂等、超时重试、错误可追踪。

### 9.2 跨阶段质量门禁

- 所有写接口必须经过：鉴权 Cookie -> CSRF -> 幂等键策略 -> 统一错误映射。
- 所有状态字段必须走 `status-map.ts`，禁止页面内硬编码状态文案。
- 每个 phase 至少补一组 E2E 用例和一组异常流用例（429/5xx/409）。

### 9.3 UI/UX 并行里程碑（建议补充）

- UX-M0（第 1 周）：设计基础冻结  
  输出：字体/色盘/间距 token、状态色语义、按钮与表单基础规范、图标集（`lucide-react`）使用规则。
- UX-M1（第 2-4 周）：用户侧关键路径体验定稿  
  输出：商品列表/详情、购物车、结算、支付结果、订单详情的低保真到高保真稿，覆盖 loading/empty/error/success 状态。
- UX-M2（第 5-8 周）：管理侧高密度操作体验定稿  
  输出：商品中台、订单运营、支付退款、物流运营页面的列表/详情/表单范式与“高风险操作确认”交互规范。
- UX-M3（第 9-10 周）：客服会话与工单体验定稿  
  输出：工单列表、会话窗、状态流转、指派与补发流程的交互稿与异常态文案规范。
- UX-M4（第 11-12 周）：可用性回归与一致性审查  
  输出：基于 CRAP + 任务优先的验收清单，修复优先级分级（P0/P1/P2）与最终视觉一致性报告。

## 10. 已确认约束与剩余风险

### 10.1 已确认约束（2026-02-28）

1. **跨域/CORS 策略**：前后端同机多容器部署，通过 Nginx 反代为统一入口。
2. **admin 权限模型**：RBAC 已在后端落地，JWT 包含前端所需 RBAC 信息。
3. **状态枚举基准**：`PayStatus` 以 DDL `orders.pay_status` 为准。
4. **PATCH 契约一致性**：`UpsertRequest` 的强校验仅用于 POST；PATCH 请求体至少包含 1 个字段（不能为空对象）。
5. **幂等规则**：所有声明 `Idempotency-Key` 的接口均必传。
6. **customerservice 实时通道**：先通过 `/users/me/ws-sessions`、`/admin/ws-sessions` 申请升级参数，再按 `CsWs**` 模型进行 WebSocket 通信。

### 10.2 剩余风险

1. **API 文档同步风险**：部分 OpenAPI 仍将 `Idempotency-Key` 标记为 optional，需与“必传”策略同步。
2. **PATCH schema 落地风险**：`product/orders` 仍有 `UpsertRequest` 复用 PATCH，需补“至少一个字段”约束并对齐校验语义。
3. **品牌设计基线风险**：首版视觉 token（字体/色盘/间距）需在 Phase 0 完成冻结，避免中后期返工。

## 11. 参考（官方文档）

- Next.js App Router（Routing & Layouts）：https://nextjs.org/docs/app
- Server and Client Components：https://nextjs.org/docs/app/getting-started/server-and-client-components
- Fetching Data：https://nextjs.org/docs/app/getting-started/fetching-data
- Updating Data / Server Actions：https://nextjs.org/docs/app/getting-started/updating-data
- Caching and Revalidating：https://nextjs.org/docs/app/getting-started/caching-and-revalidating
- Route Handlers：https://nextjs.org/docs/app/getting-started/route-handlers
- Backend for Frontend（Guide）：https://nextjs.org/docs/app/guides/backend-for-frontend
